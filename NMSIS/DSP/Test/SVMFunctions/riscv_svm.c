#include "riscv_math.h"
#include <stdint.h>
#include <stdlib.h>
#include "../common.h"

#include "../HelperFunctions/math_helper.c"
#include "../HelperFunctions/ref_helper.c"

#include <stdio.h>

int test_flag_error = 0;

BENCH_DECLARE_VAR();
void linearSVM(void)
{
    /*
      The linear SVM instance containing all parameters.
      Those parameters can be generated with the python library scikit-learn.
    */
    riscv_svm_linear_instance_f32 params;

    /*
      Parameters generated by a training of the SVM classifier
      using scikit-learn and some random input data.
     */
    #define NB_SUPPORT_VECTORS_1 5

    /*
      Dimension of the vector space. A vector is your feature.
      It could, for instance, be the pixels of a picture or the FFT of a signal.
     */
    #define VECTOR_DIMENSION_1 2

    const float32_t dualCoefficients[NB_SUPPORT_VECTORS_1]={-0.35546785f,-1.0f,-0.36854031f,1.0f,0.72400816f}; /* Dual coefficients */

    const float32_t supportVectors[NB_SUPPORT_VECTORS_1*VECTOR_DIMENSION_1]={0.72036631f,1.03756244f,-0.38866912f,-0.12420514f,-2.2480224f,1.06849044f,-0.85917311f,0.1668838f,-0.15631996f,-0.82489954f}; /* Support vectors */

    /*
      Class A is identified with value 0.
      Class B is identified with value 1.

      This array is used by the SVM functions to do a conversion and ease the comparison
      with the Python code where different values could be used.
     */
    const int32_t classes[2]={0, 1};
    /* Array of input data */
    float32_t in[VECTOR_DIMENSION_1];

    /* Result of the classifier */
    int32_t result;

    /*
        Initialization of the SVM instance parameters.
        Additional parameters (intercept, degree, coef0 and gamma) are also coming from Python.
    */
    riscv_svm_linear_init_f32(&params,
        NB_SUPPORT_VECTORS_1,
        VECTOR_DIMENSION_1,
        0.116755f,              /* Intercept */
        dualCoefficients,
        supportVectors,
        classes
    );


    /*
        Input data.
    */
    in[0] = 0.8f;
    in[1] = 1.1f;

    BENCH_START(riscv_svm_linear_predict_f32);
    riscv_svm_linear_predict_f32(&params, in, &result);
    BENCH_END(riscv_svm_linear_predict_f32);

    /* Result should be 0 : First class */
    if (result != 0) {
        BENCH_ERROR(riscv_svm_linear_predict_f32);
        printf("expect: %d, actual: %d\n", 0, result);
        test_flag_error = 1;
    }

    /*
        Input data.
    */
    in[0] = 3.0f;
    in[1] = -2.0f;

    riscv_svm_linear_predict_f32(&params, in, &result);

    /* Result should be 1 : Second class */
    if (result != 1) {
        BENCH_ERROR(riscv_svm_linear_predict_f32);
        printf("expect: %d, actual: %d\n", 1, result);
        test_flag_error = 1;
    }
    BENCH_STATUS(riscv_svm_linear_predict_f32);

    // f16
#if defined (RISCV_FLOAT16_SUPPORTED)
    riscv_svm_linear_instance_f16 params_f16;

    float16_t in_f16[VECTOR_DIMENSION_1];

    const float16_t dualCoefficients_f16[NB_SUPPORT_VECTORS_1] = {}; /* Dual coefficients */
    riscv_float_to_f16(dualCoefficients, (float16_t *)dualCoefficients_f16, NB_SUPPORT_VECTORS_1);

    const float16_t supportVectors_f16[NB_SUPPORT_VECTORS_1*VECTOR_DIMENSION_1]; /* Support vectors */
    riscv_float_to_f16(supportVectors, (float16_t *)supportVectors_f16, NB_SUPPORT_VECTORS_1*VECTOR_DIMENSION_1);

    riscv_svm_linear_init_f16(&params_f16,
        NB_SUPPORT_VECTORS_1,
        VECTOR_DIMENSION_1,
        (float16_t)0.116755f,              /* Intercept */
        dualCoefficients_f16,
        supportVectors_f16,
        classes
    );

    in_f16[0] = (float16_t)0.8f;
    in_f16[1] = (float16_t)1.1f;

    BENCH_START(riscv_svm_linear_predict_f16);
    riscv_svm_linear_predict_f16(&params_f16, in_f16, &result);
    BENCH_END(riscv_svm_linear_predict_f16);

    /* Result should be 0 : First class */
    if (result != 0) {
        BENCH_ERROR(riscv_svm_linear_predict_f16);
        printf("expect: %d, actual: %d\n", 0, result);
        test_flag_error = 1;
    }

    /*
        Input data.
    */
    in_f16[0] = (float16_t)3.0f;
    in_f16[1] = (float16_t)-2.0f;

    riscv_svm_linear_predict_f16(&params_f16, in_f16, &result);

    /* Result should be 1 : Second class */
    if (result != 1) {
        BENCH_ERROR(riscv_svm_linear_predict_f16);
        printf("expect: %d, actual: %d\n", 1, result);
        test_flag_error = 1;
    }
    BENCH_STATUS(riscv_svm_linear_predict_f16);
#endif /* defined (RISCV_FLOAT16_SUPPORTED) */
}

void polynomialSVM(void)
{
    /*
      The polynomial SVM instance containing all parameters.
      Those parameters can be generated with the python library scikit-learn.
     */
    riscv_svm_polynomial_instance_f32 params;

    /*
      Parameters generated by a training of the SVM classifier
      using scikit-learn and some random input data.
     */
    #define NB_SUPPORT_VECTORS_2 9

    /*
      Dimension of the vector space. A vector is your feature.
      It could, for instance, be the pixels of a picture or the FFT of a signal.
     */
    #define VECTOR_DIMENSION_2 2

    const float32_t dualCoefficients[NB_SUPPORT_VECTORS_2]={-0.05355985f,-0.08799571f,0.03355538f,0.03568506f,0.02952993f,0.00270412f,0.01743034f,0.01808445f,0.00456627f}; /* Dual coefficients */

    const float32_t supportVectors[NB_SUPPORT_VECTORS_2*VECTOR_DIMENSION_2]={1.35662086f,0.39208881f,-1.01276844f,-1.13381492f,2.18118916f,1.76274021f,-2.62629126f,-0.81061583f,-0.86876703f,-2.74531146f,-0.82722208f,2.77116307f,-1.51435674f,2.40297933f,2.61838172f,-1.22023814f,2.0558457f,-2.00230947f}; /* Support vectors */

    /*
      Class A is identified with value 0.
      Class B is identified with value 1.

      This array is used by the SVM functions to do a conversion and ease the comparison
      with the Python code where different values could be used.
     */
    const int32_t classes[2]={0, 1};
        /* Array of input data */
    float32_t in[VECTOR_DIMENSION_2];

    /* Result of the classifier */
    int32_t result;

    /*
        Initialization of the SVM instance parameters.
        Additional parameters (intercept, degree, coef0 and gamma) are also coming from Python.
    */
    riscv_svm_polynomial_init_f32(&params,
        NB_SUPPORT_VECTORS_2,
        VECTOR_DIMENSION_2,
        -1.704476f,        /* Intercept */
        dualCoefficients,
        supportVectors,
        classes,
        3,                 /* degree */
        1.100000f,         /* Coef0 */
        0.500000f          /* Gamma */
    );


    /*
        Input data.
        It is corresponding to a point inside the first class.
    */
    in[0] = 0.4f;
    in[1] = 0.1f;
    BENCH_START(riscv_svm_polynomial_predict_f32);
    riscv_svm_polynomial_predict_f32(&params, in, &result);
    BENCH_END(riscv_svm_polynomial_predict_f32);
    /* Result should be 0 : First class */
    if (result != 0) {
        BENCH_ERROR(riscv_svm_polynomial_predict_f32);
        printf("expect: %d, actual: %d\n", 0, result);
        test_flag_error = 1;
    }

    /*
        This input vector is corresponding to a point inside the second class.
    */
    in[0] = 3.0f;
    in[1] = 0.0f;

    riscv_svm_polynomial_predict_f32(&params, in, &result);

    /* Result should be 0 : First class */
    if (result != 1) {
        BENCH_ERROR(riscv_svm_polynomial_predict_f32);
        printf("expect: %d, actual: %d\n", 1, result);
        test_flag_error = 1;
    }
    BENCH_STATUS(riscv_svm_polynomial_predict_f32);

    // f16
#if defined (RISCV_FLOAT16_SUPPORTED)
    riscv_svm_polynomial_instance_f16 params_f16;

    const float16_t dualCoefficients_f16[NB_SUPPORT_VECTORS_2]; /* Dual coefficients */
    riscv_float_to_f16(dualCoefficients, (float16_t *)dualCoefficients_f16, NB_SUPPORT_VECTORS_2);

    const float16_t supportVectors_f16[NB_SUPPORT_VECTORS_2*VECTOR_DIMENSION_2]; /* Support vectors */
    riscv_float_to_f16(supportVectors, (float16_t *)supportVectors_f16, NB_SUPPORT_VECTORS_2*VECTOR_DIMENSION_2);

    float16_t in_f16[VECTOR_DIMENSION_2];

    riscv_svm_polynomial_init_f16(&params_f16,
        NB_SUPPORT_VECTORS_2,
        VECTOR_DIMENSION_2,
        (float16_t)-1.704476f,        /* Intercept */
        dualCoefficients_f16,
        supportVectors_f16,
        classes,
        3,                 /* degree */
        (float16_t)1.100000f,         /* Coef0 */
        (float16_t)0.500000f          /* Gamma */
    );

    in_f16[0] = (float16_t)0.4f;
    in_f16[1] = (float16_t)0.1f;;
    BENCH_START(riscv_svm_polynomial_predict_f16);
    riscv_svm_polynomial_predict_f16(&params_f16, in_f16, &result);
    BENCH_END(riscv_svm_polynomial_predict_f16);
    /* Result should be 0 : First class */
    if (result != 0) {
        BENCH_ERROR(riscv_svm_polynomial_predict_f16);
        printf("expect: %d, actual: %d\n", 0, result);
        test_flag_error = 1;
    }

    in_f16[0] = (float16_t)3.0f;
    in_f16[1] = 0.0;

    riscv_svm_polynomial_predict_f16(&params_f16, in_f16, &result);

    /* Result should be 0 : First class */
    if (result != 1) {
        BENCH_ERROR(riscv_svm_polynomial_predict_f16);
        printf("expect: %d, actual: %d\n", 1, result);
        test_flag_error = 1;
    }
    BENCH_STATUS(riscv_svm_polynomial_predict_f16);
#endif /* defined (RISCV_FLOAT16_SUPPORTED) */
}

void rbfSVM(void)
{
    /*
      The rbf SVM instance containing all parameters.
      Those parameters can be generated with the python library scikit-learn.
     */
    riscv_svm_rbf_instance_f32 params;

    /*
      Parameters generated by a training of the SVM classifier
      using scikit-learn and some random input data.
     */
    #define NB_SUPPORT_VECTORS_3 12

    /*
      Dimension of the vector space. A vector is your feature.
      It could, for instance, be the pixels of a picture or the FFT of a signal.
     */
    #define VECTOR_DIMENSION_3 2

    const float32_t dualCoefficients[NB_SUPPORT_VECTORS_3]={-1.0f,-0.24755389f,-0.25096047f,-1.0f,0.46499702f,0.0444816f,0.2506171f,0.33291225f,0.40335676f,0.39688342f,0.41563006f,0.18963614f}; /* Dual coefficients */

    const float32_t supportVectors[NB_SUPPORT_VECTORS_3*VECTOR_DIMENSION_3]={0.63477121f,-0.59986042f,-0.12523598f,0.63629978f,0.06312245f,-0.59010787f,-0.45084347f,0.5881345f,2.95843437f,-0.42401806f,-0.59248704f,-2.96471627f,-2.15141529f,-1.92858494f,0.55448567f,3.17860023f,-1.1236758f,2.7331152f,-0.05251905f,-3.00311314f,-2.86027661f,0.78232224f,-2.77279855f,-1.32510909f}; /* Support vectors */

    /*
      Class A is identified with value 0.
      Class B is identified with value 1.

      This array is used by the SVM functions to do a conversion and ease the comparison
      with the Python code where different values could be used.
     */
    const int32_t classes[2]={0, 1};
    float32_t in[VECTOR_DIMENSION_3];

    /* Result of the classifier */
    int32_t result;


    /*
        Initialization of the SVM instance parameters.
        Additional parameters (intercept, degree, coef0 and gamma) are also coming from Python.
    */
    riscv_svm_rbf_init_f32(&params,
        NB_SUPPORT_VECTORS_3,
        VECTOR_DIMENSION_3,
        0.607375f,        /* Intercept */
        dualCoefficients,
        supportVectors,
        classes,
        0.500000f          /* Gamma */
    );

    /*
        Input data.
        It is corresponding to a point inside the first class.
    */
    in[0] = 0.4f;
    in[1] = 0.1f;
    BENCH_START(riscv_svm_rbf_predict_f32);
    riscv_svm_rbf_predict_f32(&params, in, &result);
    BENCH_END(riscv_svm_rbf_predict_f32);
    /* Result should be 0 : First class */
    if (result != 0) {
        BENCH_ERROR(riscv_svm_rbf_predict_f32);
        printf("expect: %d, actual: %d\n", 0, result);
        test_flag_error = 1;
    }

    /*
        This input vector is corresponding to a point inside the second class.
    */
    in[0] = 3.0f;
    in[1] = 0.0f;

    riscv_svm_rbf_predict_f32(&params, in, &result);

    /* Result should be 0 : First class */
    if (result != 1) {
        BENCH_ERROR(riscv_svm_rbf_predict_f32);
        printf("expect: %d, actual: %d\n", 1, result);
        test_flag_error = 1;
    }
    BENCH_STATUS(riscv_svm_rbf_predict_f32);

   // f16
#if defined (RISCV_FLOAT16_SUPPORTED)
    riscv_svm_rbf_instance_f16 params_f16;

    const float16_t dualCoefficients_f16[NB_SUPPORT_VECTORS_3]; /* Dual coefficients */
    riscv_float_to_f16(dualCoefficients, (float16_t *)dualCoefficients_f16, NB_SUPPORT_VECTORS_3);

    const float16_t supportVectors_f16[NB_SUPPORT_VECTORS_3*VECTOR_DIMENSION_3]; /* Support vectors */
    riscv_float_to_f16(supportVectors, (float16_t *)supportVectors_f16, NB_SUPPORT_VECTORS_3*VECTOR_DIMENSION_3);

    float16_t in_16[VECTOR_DIMENSION_3];

    riscv_svm_rbf_init_f16(&params_f16,
        NB_SUPPORT_VECTORS_3,
        VECTOR_DIMENSION_3,
        (float16_t)0.607375f,        /* Intercept */
        dualCoefficients_f16,
        supportVectors_f16,
        classes,
        (float16_t)0.500000f          /* Gamma */
    );

    in_16[0] = (float16_t)0.4f;
    in_16[1] = (float16_t)0.1f;
    BENCH_START(riscv_svm_rbf_predict_f16);
    riscv_svm_rbf_predict_f16(&params_f16, in_16, &result);
    BENCH_END(riscv_svm_rbf_predict_f16);
    /* Result should be 0 : First class */
    if (result != 0) {
        BENCH_ERROR(riscv_svm_rbf_predict_f16);
        printf("expect: %d, actual: %d\n", 0, result);
        test_flag_error = 1;
    }

    in_16[0] = (float16_t)3.0f;
    in_16[1] = 0.0;

    riscv_svm_rbf_predict_f16(&params_f16, in_16, &result);

    /* Result should be 0 : First class */
    if (result != 1) {
        BENCH_ERROR(riscv_svm_rbf_predict_f16);
        printf("expect: %d, actual: %d\n", 1, result);
        test_flag_error = 1;
    }
    BENCH_STATUS(riscv_svm_rbf_predict_f16);
#endif /* defined (RISCV_FLOAT16_SUPPORTED) */
}

void sigmoidSVM(void)
{
    /*
      The sigmoid SVM instance containing all parameters.
      Those parameters can be generated with the python library scikit-learn.
     */
    riscv_svm_sigmoid_instance_f32 params;

    /*
      Parameters generated by a training of the SVM classifier
      using scikit-learn and some random input data.
     */
    #define NB_SUPPORT_VECTORS_4 2

    /*
      Dimension of the vector space. A vector is your feature.
      It could, for instance, be the pixels of a picture or the FFT of a signal.
     */
    #define VECTOR_DIMENSION_4 2

    const float32_t dualCoefficients[NB_SUPPORT_VECTORS_4]={-0.5006101f,0.5006101f}; /* Dual coefficients */

    const float32_t supportVectors[NB_SUPPORT_VECTORS_4*VECTOR_DIMENSION_4]={-1.33358633f,3.46798561f,-0.56781298f,-2.79117593f}; /* Support vectors */

    /*
      Class A is identified with value 0.
      Class B is identified with value 1.

      This array is used by the SVM functions to do a conversion and ease the comparison
      with the Python code where different values could be used.
     */
    const int32_t classes[2] = {0, 1};
    /* Array of input data */
    float32_t in[VECTOR_DIMENSION_4];

    /* Result of the classifier */
    int32_t result;


    /*
        Initialization of the SVM instance parameters.
        Additional parameters (intercept, degree, coef0 and gamma) are also coming from Python.
    */
    riscv_svm_sigmoid_init_f32(&params,
        NB_SUPPORT_VECTORS_4,
        VECTOR_DIMENSION_4,
        0.000017f,        /* Intercept */
        dualCoefficients,
        supportVectors,
        classes,
        1.100000f,         /* Coef0 */
        0.500000f          /* Gamma */
    );

    /*
        Input data.
        It is corresponding to a point inside the first class.
    */
    in[0] = 0.4f;
    in[1] = 0.1f;
    BENCH_START(riscv_svm_sigmoid_predict_f32);
    riscv_svm_sigmoid_predict_f32(&params, in, &result);
    BENCH_END(riscv_svm_sigmoid_predict_f32);
    /* Result should be 0 : First class */
    if (result != 0) {
        BENCH_ERROR(riscv_svm_sigmoid_predict_f32);
        printf("expect: %d, actual: %d\n", 0, result);
        test_flag_error = 1;
    }
    BENCH_STATUS(riscv_svm_sigmoid_predict_f32);

    /*
        This input vector is corresponding to a point inside the second class.
    */
    in[0] = 3.0f;
    in[1] = 0.0f;

    riscv_svm_sigmoid_predict_f32(&params, in, &result);

    /* Result should be 0 : First class */
    if (result != 1) {
        BENCH_ERROR(riscv_svm_sigmoid_predict_f32);
        printf("expect: %d, actual: %d\n", 1, result);
        test_flag_error = 1;
    }
    BENCH_STATUS(riscv_svm_sigmoid_predict_f32);

    // f16
#if defined (RISCV_FLOAT16_SUPPORTED)
    riscv_svm_sigmoid_instance_f16 params_f16;

    const float16_t dualCoefficients_f16[NB_SUPPORT_VECTORS_4]; /* Dual coefficients */
    riscv_float_to_f16(dualCoefficients, (float16_t *)dualCoefficients_f16, NB_SUPPORT_VECTORS_4);

    const float16_t supportVectors_f16[NB_SUPPORT_VECTORS_4*VECTOR_DIMENSION_4]; /* Support vectors */
    riscv_float_to_f16(supportVectors, (float16_t *)supportVectors_f16, NB_SUPPORT_VECTORS_4*VECTOR_DIMENSION_4);

    float16_t in_f16[VECTOR_DIMENSION_4];

    riscv_svm_sigmoid_init_f16(&params_f16,
        NB_SUPPORT_VECTORS_4,
        VECTOR_DIMENSION_4,
        (float16_t)0.000017f,        /* intercept */
        dualCoefficients_f16,
        supportVectors_f16,
        classes,
        (float16_t)1.100000f,         /* Coef0 */
        (float16_t)0.500000f          /* Gamma */
    );

    in_f16[0] = (float16_t)0.4f;
    in_f16[1] = (float16_t)0.1f;
    BENCH_START(riscv_svm_sigmoid_predict_f16);
    riscv_svm_sigmoid_predict_f16(&params_f16, in_f16, &result);
    BENCH_END(riscv_svm_sigmoid_predict_f16);
    /* Result should be 0 : First class */
    if (result != 0) {
        BENCH_ERROR(riscv_svm_sigmoid_predict_f16);
        printf("expect: %d, actual: %d\n", 0, result);
        test_flag_error = 1;
    }
    BENCH_STATUS(riscv_svm_sigmoid_predict_f16);

    /*
        This in_f16put vector is correspondin_f16g to a poin_f16t in_f16side the second class.
    */
    in_f16[0] = (float16_t)3.0f;
    in_f16[1] = 0.0;

    riscv_svm_sigmoid_predict_f16(&params_f16, in_f16, &result);

    /* Result should be 0 : First class */
    if (result != 1) {
        BENCH_ERROR(riscv_svm_sigmoid_predict_f16);
        printf("expect: %d, actual: %d\n", 1, result);
        test_flag_error = 1;
    }
    BENCH_STATUS(riscv_svm_sigmoid_predict_f16);
#endif /* defined (RISCV_FLOAT16_SUPPORTED) */
}

int main(void)
{
    int i;
    BENCH_INIT();
    linearSVM();
    polynomialSVM();
    rbfSVM();
    sigmoidSVM();

    if (test_flag_error) {
        printf("test error apprears, please recheck.\n");
        return 1;
    } else {
        printf("all test are passed. Well done!\n");
    }
    return 0;
};
