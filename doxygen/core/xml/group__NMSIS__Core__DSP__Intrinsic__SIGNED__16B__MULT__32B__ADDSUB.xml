<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB" kind="group">
    <compoundname>NMSIS_Core_DSP_Intrinsic_SIGNED_16B_MULT_32B_ADDSUB</compoundname>
    <title>Signed 16-bit Multiply 32-bit Add/Subtract Instructions</title>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga3a415f9cbeefb992bc791099e73c8794" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_KMABB</definition>
        <argsstring>(long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KMABB</name>
        <param>
          <type>long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KMABB (SIMD Saturating Signed Multiply Bottom Halfs &amp; Add) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KMABB<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMABT<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMATT<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Multiply the signed 16-bit content of 32-bit elements in a register with the 16-bit content of 32-bit elements in another register and add the result to the content of 32-bit elements in the third register. The addition result may be saturated and is written to the third register.<itemizedlist>
<listitem><para>KMABB: rd.W[x] + bottom*bottom (per 32-bit element)</para></listitem><listitem><para>KMABT rd.W[x] + bottom*top (per 32-bit element)</para></listitem><listitem><para>KMATT rd.W[x] + top*top (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KMABB</computeroutput> instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2. For the <computeroutput>KMABT</computeroutput> instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. For the <computeroutput>KMATT</computeroutput> instruction, it multiplies the top 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. The multiplication result is added to the content of 32-bit elements in Rd. If the addition result is beyond the Q31 number range (-2^31 &lt;= Q31 &lt;= 2^31-1), it is saturated to the range and the OV bit is set to<orderedlist>
<listitem><para>The results after saturation are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.</para></listitem></orderedlist>
</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);<sp/></highlight><highlight class="comment">//<sp/>KMABB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);<sp/></highlight><highlight class="comment">//<sp/>KMABT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1]);<sp/></highlight><highlight class="comment">//<sp/>KMATT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&gt;<sp/>(2^31)-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>(2^31)-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&lt;<sp/>-2^31)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>-2^31;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>res[x];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="2613" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="2613" bodyend="2617"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga3fe17f8a2e70a69f1751a1c0093c3158" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_KMABT</definition>
        <argsstring>(long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KMABT</name>
        <param>
          <type>long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KMABT (SIMD Saturating Signed Multiply Bottom &amp; Top Halfs &amp; Add) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KMABB<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMABT<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMATT<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Multiply the signed 16-bit content of 32-bit elements in a register with the 16-bit content of 32-bit elements in another register and add the result to the content of 32-bit elements in the third register. The addition result may be saturated and is written to the third register.<itemizedlist>
<listitem><para>KMABB: rd.W[x] + bottom*bottom (per 32-bit element)</para></listitem><listitem><para>KMABT rd.W[x] + bottom*top (per 32-bit element)</para></listitem><listitem><para>KMATT rd.W[x] + top*top (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KMABB</computeroutput> instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2. For the <computeroutput>KMABT</computeroutput> instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. For the <computeroutput>KMATT</computeroutput> instruction, it multiplies the top 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. The multiplication result is added to the content of 32-bit elements in Rd. If the addition result is beyond the Q31 number range (-2^31 &lt;= Q31 &lt;= 2^31-1), it is saturated to the range and the OV bit is set to<orderedlist>
<listitem><para>The results after saturation are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.</para></listitem></orderedlist>
</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);<sp/></highlight><highlight class="comment">//<sp/>KMABB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);<sp/></highlight><highlight class="comment">//<sp/>KMABT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1]);<sp/></highlight><highlight class="comment">//<sp/>KMATT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&gt;<sp/>(2^31)-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>(2^31)-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&lt;<sp/>-2^31)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>-2^31;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>res[x];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="2676" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="2676" bodyend="2680"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1gad6267dd09022516bcd77ce742b8b40ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_KMATT</definition>
        <argsstring>(long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KMATT</name>
        <param>
          <type>long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KMATT (SIMD Saturating Signed Multiply Top Halfs &amp; Add) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KMABB<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMABT<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMATT<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Multiply the signed 16-bit content of 32-bit elements in a register with the 16-bit content of 32-bit elements in another register and add the result to the content of 32-bit elements in the third register. The addition result may be saturated and is written to the third register.<itemizedlist>
<listitem><para>KMABB: rd.W[x] + bottom*bottom (per 32-bit element)</para></listitem><listitem><para>KMABT rd.W[x] + bottom*top (per 32-bit element)</para></listitem><listitem><para>KMATT rd.W[x] + top*top (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KMABB</computeroutput> instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2. For the <computeroutput>KMABT</computeroutput> instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. For the <computeroutput>KMATT</computeroutput> instruction, it multiplies the top 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. The multiplication result is added to the content of 32-bit elements in Rd. If the addition result is beyond the Q31 number range (-2^31 &lt;= Q31 &lt;= 2^31-1), it is saturated to the range and the OV bit is set to<orderedlist>
<listitem><para>The results after saturation are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.</para></listitem></orderedlist>
</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);<sp/></highlight><highlight class="comment">//<sp/>KMABB</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);<sp/></highlight><highlight class="comment">//<sp/>KMABT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1]);<sp/></highlight><highlight class="comment">//<sp/>KMATT</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&gt;<sp/>(2^31)-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>(2^31)-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&lt;<sp/>-2^31)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>-2^31;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>res[x];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="2739" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="2739" bodyend="2743"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga84ab72987eeee69e2392965d8d8944f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_KMADA</definition>
        <argsstring>(long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KMADA</name>
        <param>
          <type>long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KMADA (SIMD Saturating Signed Multiply Two Halfs and Two Adds) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KMADA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMAXDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from 32-bit elements in two registers; and then adds the two 32-bit results and 32-bit elements in a third register together. The addition result may be saturated.<itemizedlist>
<listitem><para>KMADA: rd.W[x] + top*top + bottom*bottom (per 32-bit element)</para></listitem><listitem><para>KMAXDA: rd.W[x] + top*bottom + bottom*top (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the `KMADA instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2 and then adds the result to the result of multiplying the top 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. For the <computeroutput>KMAXDA</computeroutput> instruction, it multiplies the top 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2 and then adds the result to the result of multiplying the bottom 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. The result is added to the content of 32-bit elements in Rd. If the addition result is beyond the Q31 number range (-2^31 &lt;= Q31 &lt;= 2^31-1), it is saturated to the range and the OV bit is set to 1. The 32-bit results after saturation are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="comment">//<sp/>KMADA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1])<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>KMAXDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&gt;<sp/>(2^31)-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>(2^31)-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&lt;<sp/>-2^31)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>-2^31;</highlight></codeline>
<codeline><highlight class="normal">OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>res[x];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="2803" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="2803" bodyend="2807"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga1cab84ebee0378b9c1069e17efdbfd69" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_KMAXDA</definition>
        <argsstring>(long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KMAXDA</name>
        <param>
          <type>long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KMAXDA (SIMD Saturating Signed Crossed Multiply Two Halfs and Two Adds) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KMADA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMAXDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from 32-bit elements in two registers; and then adds the two 32-bit results and 32-bit elements in a third register together. The addition result may be saturated.<itemizedlist>
<listitem><para>KMADA: rd.W[x] + top*top + bottom*bottom (per 32-bit element)</para></listitem><listitem><para>KMAXDA: rd.W[x] + top*bottom + bottom*top (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the `KMADA instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2 and then adds the result to the result of multiplying the top 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. For the <computeroutput>KMAXDA</computeroutput> instruction, it multiplies the top 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2 and then adds the result to the result of multiplying the bottom 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. The result is added to the content of 32-bit elements in Rd. If the addition result is beyond the Q31 number range (-2^31 &lt;= Q31 &lt;= 2^31-1), it is saturated to the range and the OV bit is set to 1. The 32-bit results after saturation are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="comment">//<sp/>KMADA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1])<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>KMAXDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&gt;<sp/>(2^31)-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>(2^31)-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&lt;<sp/>-2^31)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>-2^31;</highlight></codeline>
<codeline><highlight class="normal">OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>res[x];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="2867" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="2867" bodyend="2871"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga6b9f5141c87a343051b03494705eeac8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_KMADS</definition>
        <argsstring>(long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KMADS</name>
        <param>
          <type>long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KMADS (SIMD Saturating Signed Multiply Two Halfs &amp; Subtract &amp; Add) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KMADS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMADRS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMAXDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from 32-bit elements in two registers; and then perform a subtraction operation between the two 32-bit results. Then add the subtraction result to the corresponding 32-bit elements in a third register. The addition result may be saturated.<itemizedlist>
<listitem><para>KMADS: rd.W[x] + (top*top - bottom*bottom) (per 32-bit element)</para></listitem><listitem><para>KMADRS: rd.W[x] + (bottom*bottom - top*top) (per 32-bit element)</para></listitem><listitem><para>KMAXDS: rd.W[x] + (top*bottom - bottom*top) (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KMADS</computeroutput> instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. For the <computeroutput>KMADRS</computeroutput> instruction, it multiplies the top 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32- bit elements in Rs2. For the <computeroutput>KMAXDS</computeroutput> instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2. The subtraction result is then added to the content of the corresponding 32-bit elements in Rd. If the addition result is beyond the Q31 number range (-2^31 &lt;= Q31 &lt;= 2^31-1), it is saturated to the range and the OV bit is set to 1. The 32-bit results after saturation are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="comment">//<sp/>KMADS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>KMADRS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>KMAXDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&gt;<sp/>(2^31)-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>(2^31)-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&lt;<sp/>-2^31)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>-2^31;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>res[x];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="2939" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="2939" bodyend="2943"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga13576aa03f836be838f491fe7cc483d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_KMADRS</definition>
        <argsstring>(long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KMADRS</name>
        <param>
          <type>long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KMADRS (SIMD Saturating Signed Multiply Two Halfs &amp; Reverse Subtract &amp; Add) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KMADS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMADRS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMAXDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from 32-bit elements in two registers; and then perform a subtraction operation between the two 32-bit results. Then add the subtraction result to the corresponding 32-bit elements in a third register. The addition result may be saturated.<itemizedlist>
<listitem><para>KMADS: rd.W[x] + (top*top - bottom*bottom) (per 32-bit element)</para></listitem><listitem><para>KMADRS: rd.W[x] + (bottom*bottom - top*top) (per 32-bit element)</para></listitem><listitem><para>KMAXDS: rd.W[x] + (top*bottom - bottom*top) (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KMADS</computeroutput> instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. For the <computeroutput>KMADRS</computeroutput> instruction, it multiplies the top 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32- bit elements in Rs2. For the <computeroutput>KMAXDS</computeroutput> instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2. The subtraction result is then added to the content of the corresponding 32-bit elements in Rd. If the addition result is beyond the Q31 number range (-2^31 &lt;= Q31 &lt;= 2^31-1), it is saturated to the range and the OV bit is set to 1. The 32-bit results after saturation are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="comment">//<sp/>KMADS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>KMADRS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>KMAXDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&gt;<sp/>(2^31)-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>(2^31)-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&lt;<sp/>-2^31)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>-2^31;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>res[x];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="3011" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="3011" bodyend="3015"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga4649629156d0af6a2e64c30ae5bee381" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_KMAXDS</definition>
        <argsstring>(long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KMAXDS</name>
        <param>
          <type>long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KMAXDS (SIMD Saturating Signed Crossed Multiply Two Halfs &amp; Subtract &amp; Add) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KMADS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMADRS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMAXDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from 32-bit elements in two registers; and then perform a subtraction operation between the two 32-bit results. Then add the subtraction result to the corresponding 32-bit elements in a third register. The addition result may be saturated.<itemizedlist>
<listitem><para>KMADS: rd.W[x] + (top*top - bottom*bottom) (per 32-bit element)</para></listitem><listitem><para>KMADRS: rd.W[x] + (bottom*bottom - top*top) (per 32-bit element)</para></listitem><listitem><para>KMAXDS: rd.W[x] + (top*bottom - bottom*top) (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KMADS</computeroutput> instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2. For the <computeroutput>KMADRS</computeroutput> instruction, it multiplies the top 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32- bit elements in Rs2. For the <computeroutput>KMAXDS</computeroutput> instruction, it multiplies the bottom 16-bit content of 32-bit elements in Rs1 with the top 16-bit content of 32-bit elements in Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of 32-bit elements in Rs1 with the bottom 16-bit content of 32-bit elements in Rs2. The subtraction result is then added to the content of the corresponding 32-bit elements in Rd. If the addition result is beyond the Q31 number range (-2^31 &lt;= Q31 &lt;= 2^31-1), it is saturated to the range and the OV bit is set to 1. The 32-bit results after saturation are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="comment">//<sp/>KMADS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>KMADRS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>KMAXDS</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>+<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&gt;<sp/>(2^31)-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>(2^31)-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&lt;<sp/>-2^31)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>-2^31;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>res[x];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="3083" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="3083" bodyend="3087"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga2de43c62af85225d40c1ac4210640925" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_KMDA</definition>
        <argsstring>(unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KMDA</name>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KMDA (SIMD Signed Multiply Two Halfs and Add) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KMDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMXDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then adds the two 32-bit results together. The addition result may be saturated.<itemizedlist>
<listitem><para>KMDA: top*top + bottom*bottom (per 32-bit element)</para></listitem><listitem><para>KMXDA: top*bottom + bottom*top (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KMDA</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then adds the result to the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32- bit elements of Rs2. For the <computeroutput>KMXDA</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then adds the result to the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. The addition result is checked for saturation. If saturation happens, the result is saturated to 2^31-1. The final results are written to Rd. The 16-bit contents are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/><sp/>Rs1.W[x]<sp/><sp/>!=<sp/><sp/>0x80008000)<sp/><sp/>or<sp/><sp/>(Rs2.W[x]<sp/><sp/>!=<sp/><sp/>0x80008000<sp/><sp/>{<sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>KMDA<sp/><sp/>Rd.W[x]<sp/><sp/>=<sp/><sp/>Rs1.W[x].H[1]<sp/><sp/>*</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Rs2.W[x].H[1])<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0];<sp/></highlight><highlight class="comment">//<sp/>KMXDA<sp/>Rd.W[x]<sp/>=<sp/>Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[0])</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">+<sp/><sp/>(Rs1.W[x].H[0]<sp/><sp/>*<sp/><sp/>Rs2.W[x].H[1];<sp/><sp/>}<sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/><sp/>{<sp/><sp/>Rd.W[x]<sp/><sp/>=<sp/><sp/>0x7fffffff;<sp/><sp/>OV<sp/><sp/>=<sp/><sp/>1;<sp/><sp/>}<sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/><sp/>RV32:<sp/><sp/>x=0<sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/><sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal">x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="3201" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="3201" bodyend="3206"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga37c752d6151fb29b43b01b2dd8af55d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_KMXDA</definition>
        <argsstring>(unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KMXDA</name>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KMXDA (SIMD Signed Crossed Multiply Two Halfs and Add) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KMDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMXDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then adds the two 32-bit results together. The addition result may be saturated.<itemizedlist>
<listitem><para>KMDA: top*top + bottom*bottom (per 32-bit element)</para></listitem><listitem><para>KMXDA: top*bottom + bottom*top (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KMDA</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then adds the result to the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32- bit elements of Rs2. For the <computeroutput>KMXDA</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then adds the result to the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. The addition result is checked for saturation. If saturation happens, the result is saturated to 2^31-1. The final results are written to Rd. The 16-bit contents are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/><sp/>Rs1.W[x]<sp/><sp/>!=<sp/><sp/>0x80008000)<sp/><sp/>or<sp/><sp/>(Rs2.W[x]<sp/><sp/>!=<sp/><sp/>0x80008000<sp/><sp/>{<sp/><sp/></highlight><highlight class="comment">//<sp/><sp/>KMDA<sp/><sp/>Rd.W[x]<sp/><sp/>=<sp/><sp/>Rs1.W[x].H[1]<sp/><sp/>*</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Rs2.W[x].H[1])<sp/>+<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0];<sp/></highlight><highlight class="comment">//<sp/>KMXDA<sp/>Rd.W[x]<sp/>=<sp/>Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[0])</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">+<sp/><sp/>(Rs1.W[x].H[0]<sp/><sp/>*<sp/><sp/>Rs2.W[x].H[1];<sp/><sp/>}<sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/><sp/>{<sp/><sp/>Rd.W[x]<sp/><sp/>=<sp/><sp/>0x7fffffff;<sp/><sp/>OV<sp/><sp/>=<sp/><sp/>1;<sp/><sp/>}<sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/><sp/>RV32:<sp/><sp/>x=0<sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/><sp/>RV64:</highlight></codeline>
<codeline><highlight class="normal">x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="3252" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="3252" bodyend="3257"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga3922fe2b6d47974c6bd85cba3f826b4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_KMSDA</definition>
        <argsstring>(long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KMSDA</name>
        <param>
          <type>long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KMSDA (SIMD Saturating Signed Multiply Two Halfs &amp; Add &amp; Subtract) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KMSDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMSXDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then subtracts the two 32-bit results from the corresponding 32-bit elements of a third register. The subtraction result may be saturated.<itemizedlist>
<listitem><para>KMSDA: rd.W[x] - top*top - bottom*bottom (per 32-bit element)</para></listitem><listitem><para>KMSXDA: rd.W[x] - top*bottom - bottom*top (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KMSDA</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>KMSXDA</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and multiplies the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. The two 32-bit multiplication results are then subtracted from the content of the corresponding 32- bit elements of Rd. If the subtraction result is beyond the Q31 number range (-2^31 &lt;= Q31 &lt;= 2^31-1), it is saturated to the range and the OV bit is set to 1. The results after saturation are written to Rd. The 16-bit contents are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="comment">//<sp/>KMSDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>-<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>KMSXDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>-<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&gt;<sp/>(2^31)-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>(2^31)-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&lt;<sp/>-2^31)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>-2^31;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>res[x];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="4301" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="4301" bodyend="4305"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1gaacebc28be147f66ab73162b37cc35ce0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_KMSXDA</definition>
        <argsstring>(long t, unsigned long a, unsigned long b)</argsstring>
        <name>__RV_KMSXDA</name>
        <param>
          <type>long</type>
          <declname>t</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>KMSXDA (SIMD Saturating Signed Crossed Multiply Two Halfs &amp; Add &amp; Subtract) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">KMSDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">KMSXDA<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then subtracts the two 32-bit results from the corresponding 32-bit elements of a third register. The subtraction result may be saturated.<itemizedlist>
<listitem><para>KMSDA: rd.W[x] - top*top - bottom*bottom (per 32-bit element)</para></listitem><listitem><para>KMSXDA: rd.W[x] - top*bottom - bottom*top (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>KMSDA</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>KMSXDA</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and multiplies the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. The two 32-bit multiplication results are then subtracted from the content of the corresponding 32- bit elements of Rd. If the subtraction result is beyond the Q31 number range (-2^31 &lt;= Q31 &lt;= 2^31-1), it is saturated to the range and the OV bit is set to 1. The results after saturation are written to Rd. The 16-bit contents are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="comment">//<sp/>KMSDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>-<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>KMSXDA</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">res[x]<sp/>=<sp/>Rd.W[x]<sp/>-<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&gt;<sp/>(2^31)-1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>(2^31)-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res[x]<sp/>&lt;<sp/>-2^31)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res[x]<sp/>=<sp/>-2^31;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>OV<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>res[x];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">t</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="4363" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="4363" bodyend="4367"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga6078c3498de77bbaeabbf7017fa023ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_SMBB16</definition>
        <argsstring>(unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMBB16</name>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMBB16 (SIMD Signed Multiply Bottom Half &amp; Bottom Half) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMBB16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMBT16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMTT16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Multiply the signed 16-bit content of the 32-bit elements of a register with the signed 16- bit content of the 32-bit elements of another register and write the result to a third register.<itemizedlist>
<listitem><para>SMBB16: W[x].bottom*W[x].bottom</para></listitem><listitem><para>SMBT16: W[x].bottom *W[x].top</para></listitem><listitem><para>SMTT16: W[x].top * W[x].top</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>SMBB16</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMBT16</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMTT16</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. The multiplication results are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0];<sp/></highlight><highlight class="comment">//<sp/>SMBB16</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1];<sp/></highlight><highlight class="comment">//<sp/>SMBT16</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1];<sp/></highlight><highlight class="comment">//<sp/>SMTT16</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0,</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="8255" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="8255" bodyend="8260"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga2f8364cbb057b9952017ad1bd3230a5e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_SMBT16</definition>
        <argsstring>(unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMBT16</name>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMBT16 (SIMD Signed Multiply Bottom Half &amp; Top Half) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMBB16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMBT16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMTT16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Multiply the signed 16-bit content of the 32-bit elements of a register with the signed 16- bit content of the 32-bit elements of another register and write the result to a third register.<itemizedlist>
<listitem><para>SMBB16: W[x].bottom*W[x].bottom</para></listitem><listitem><para>SMBT16: W[x].bottom *W[x].top</para></listitem><listitem><para>SMTT16: W[x].top * W[x].top</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>SMBB16</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMBT16</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMTT16</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. The multiplication results are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0];<sp/></highlight><highlight class="comment">//<sp/>SMBB16</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1];<sp/></highlight><highlight class="comment">//<sp/>SMBT16</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1];<sp/></highlight><highlight class="comment">//<sp/>SMTT16</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0,</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="8307" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="8307" bodyend="8312"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1gab253cabd0fb5ac51b6b897cd3e8d6e0f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_SMTT16</definition>
        <argsstring>(unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMTT16</name>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMTT16 (SIMD Signed Multiply Top Half &amp; Top Half) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMBB16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMBT16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMTT16<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Multiply the signed 16-bit content of the 32-bit elements of a register with the signed 16- bit content of the 32-bit elements of another register and write the result to a third register.<itemizedlist>
<listitem><para>SMBB16: W[x].bottom*W[x].bottom</para></listitem><listitem><para>SMBT16: W[x].bottom *W[x].top</para></listitem><listitem><para>SMTT16: W[x].top * W[x].top</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>SMBB16</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMBT16</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMTT16</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. The multiplication results are written to Rd. The 16-bit contents of Rs1 and Rs2 are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0];<sp/></highlight><highlight class="comment">//<sp/>SMBB16</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1];<sp/></highlight><highlight class="comment">//<sp/>SMBT16</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1];<sp/></highlight><highlight class="comment">//<sp/>SMTT16</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV32:<sp/>x=0,</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>RV64:<sp/>x=1...0</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="8359" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="8359" bodyend="8364"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga056df0d47cc4dcef5739bb15f2a324ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_SMDS</definition>
        <argsstring>(unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMDS</name>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMDS (SIMD Signed Multiply Two Halfs and Subtract) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMDRS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMXDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then perform a subtraction operation between the two 32-bit results.<itemizedlist>
<listitem><para>SMDS: top*top - bottom*bottom (per 32-bit element)</para></listitem><listitem><para>SMDRS: bottom*bottom - top*top (per 32-bit element)</para></listitem><listitem><para>SMXDS: top*bottom - bottom*top (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>SMDS</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMDRS</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMXDS</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. The subtraction result is written to the corresponding 32-bit element of Rd. The 16-bit contents of multiplication are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>SMDS:</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);</highlight></codeline>
<codeline><highlight class="normal">*<sp/>SMDRS:</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal">*<sp/>SMXDS:</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="8418" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="8418" bodyend="8423"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1gafab251aa9c5e64dc004c9dc3b8c7c0dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_SMDRS</definition>
        <argsstring>(unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMDRS</name>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMDRS (SIMD Signed Multiply Two Halfs and Reverse Subtract) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMDRS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMXDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then perform a subtraction operation between the two 32-bit results.<itemizedlist>
<listitem><para>SMDS: top*top - bottom*bottom (per 32-bit element)</para></listitem><listitem><para>SMDRS: bottom*bottom - top*top (per 32-bit element)</para></listitem><listitem><para>SMXDS: top*bottom - bottom*top (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>SMDS</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMDRS</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMXDS</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. The subtraction result is written to the corresponding 32-bit element of Rd. The 16-bit contents of multiplication are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>SMDS:</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);</highlight></codeline>
<codeline><highlight class="normal">*<sp/>SMDRS:</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal">*<sp/>SMXDS:</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="8477" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="8477" bodyend="8482"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      <memberdef kind="function" id="group__NMSIS__Core__DSP__Intrinsic__SIGNED__16B__MULT__32B__ADDSUB_1ga45c60f7cb5ae0e2ddaeca68e0a76283b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__NMSIS__Core__CompilerControl_1gab904513442afdf77d4f8c74f23cbb040" kindref="member">__STATIC_FORCEINLINE</ref> long</type>
        <definition>__STATIC_FORCEINLINE long __RV_SMXDS</definition>
        <argsstring>(unsigned long a, unsigned long b)</argsstring>
        <name>__RV_SMXDS</name>
        <param>
          <type>unsigned long</type>
          <declname>a</declname>
        </param>
        <param>
          <type>unsigned long</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>SMXDS (SIMD Signed Crossed Multiply Two Halfs and Subtract) </para>        </briefdescription>
        <detaileddescription>
<para><bold>Type</bold>: SIMD</para><para><bold>Syntax</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">SMDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMDRS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
<codeline><highlight class="normal">SMXDS<sp/>Rd,<sp/>Rs1,<sp/>Rs2</highlight></codeline>
</programlisting></para><para><bold>Purpose</bold>:<linebreak/>
Do two signed 16-bit multiplications from the 32-bit elements of two registers; and then perform a subtraction operation between the two 32-bit results.<itemizedlist>
<listitem><para>SMDS: top*top - bottom*bottom (per 32-bit element)</para></listitem><listitem><para>SMDRS: bottom*bottom - top*top (per 32-bit element)</para></listitem><listitem><para>SMXDS: top*bottom - bottom*top (per 32-bit element)</para></listitem></itemizedlist>
</para><para><bold>Description</bold>:<linebreak/>
For the <computeroutput>SMDS</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMDRS</computeroutput> instruction, it multiplies the top 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the bottom 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. For the <computeroutput>SMXDS</computeroutput> instruction, it multiplies the bottom 16-bit content of the 32-bit elements of Rs1 with the top 16-bit content of the 32-bit elements of Rs2 and then subtracts the result from the result of multiplying the top 16-bit content of the 32-bit elements of Rs1 with the bottom 16-bit content of the 32-bit elements of Rs2. The subtraction result is written to the corresponding 32-bit element of Rd. The 16-bit contents of multiplication are treated as signed integers.</para><para><bold>Operations</bold>:<linebreak/>
<programlisting><codeline><highlight class="normal">*<sp/>SMDS:</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0]);</highlight></codeline>
<codeline><highlight class="normal">*<sp/>SMDRS:</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
<codeline><highlight class="normal">*<sp/>SMXDS:</highlight></codeline>
<codeline><highlight class="normal">Rd.W[x]<sp/>=<sp/>(Rs1.W[x].H[1]<sp/>*<sp/>Rs2.W[x].H[0])<sp/>-<sp/>(Rs1.W[x].H[0]<sp/>*<sp/>Rs2.W[x].H[1]);</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">a</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">b</parametername>
</parameternamelist>
<parameterdescription>
<para></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" line="8536" column="1" bodyfile="/home/travis/build/Nuclei-Software/NMSIS/NMSIS/Core/Include/core_feature_dsp.h" bodystart="8536" bodyend="8541"/>
        <references refid="group__NMSIS__Core__CompilerControl_1ga1378040bcf22428955c6e3ce9c2053cd" compoundref="nmsis__gcc_8h" startline="59">__ASM</references>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Signed 16-bit Multiply 32-bit Add/Subtract Instructions. </para>    </briefdescription>
    <detaileddescription>
<para>there are 18 Signed 16-bit Multiply 32-bit Add/Subtract Instructions </para>    </detaileddescription>
  </compounddef>
</doxygen>
