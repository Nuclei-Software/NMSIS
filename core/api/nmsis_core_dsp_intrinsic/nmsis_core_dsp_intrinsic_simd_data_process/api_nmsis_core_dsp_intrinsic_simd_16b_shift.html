<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SIMD 16-bit Shift Instructions &mdash; NMSIS 1.1.1 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="SIMD 8-bit Shift Instructions" href="api_nmsis_core_dsp_intrinsic_simd_8b_shift.html" />
    <link rel="prev" title="SIMD 8-bit Addition &amp; Subtraction Instructions" href="api_nmsis_core_dsp_intrinsic_simd_8b_addsub.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html">
            <img src="../../../../_static/nmsis_logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.1.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction/introduction.html">Nuclei MCU Software Interface Standard(NMSIS)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../index.html">NMSIS Core</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../get_started.html">Using NMSIS in Embedded Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../core_templates.html">NMSIS-Core Device Templates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../register_mapping.html">Register Mapping</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html">NMSIS Core API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../core_version_control.html">Version Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_compiler_control.html">Compiler Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_csr_access.html">Core CSR Register Access</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_csr_encoding.html">Core CSR Encoding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_register_type.html">Register Define and Type Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_intrinsics.html">CPU Intrinsic Functions</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../../api_nmsis_core_dsp_intrinsic.html">Intrinsic Functions for SIMD Instructions</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="../api_nmsis_core_dsp_intrinsic_simd_data_process.html">SIMD Data Processing Instructions</a><ul class="current">
<li class="toctree-l5"><a class="reference internal" href="api_nmsis_core_dsp_intrinsic_simd_16b_addsub.html">SIMD 16-bit Add/Subtract Instructions</a></li>
<li class="toctree-l5"><a class="reference internal" href="api_nmsis_core_dsp_intrinsic_simd_8b_addsub.html">SIMD 8-bit Addition &amp; Subtraction Instructions</a></li>
<li class="toctree-l5 current"><a class="current reference internal" href="#">SIMD 16-bit Shift Instructions</a></li>
<li class="toctree-l5"><a class="reference internal" href="api_nmsis_core_dsp_intrinsic_simd_8b_shift.html">SIMD 8-bit Shift Instructions</a></li>
<li class="toctree-l5"><a class="reference internal" href="api_nmsis_core_dsp_intrinsic_simd_16b_cmp.html">SIMD 16-bit Compare Instructions</a></li>
<li class="toctree-l5"><a class="reference internal" href="api_nmsis_core_dsp_intrinsic_simd_8b_cmp.html">SIMD 8-bit Compare Instructions</a></li>
<li class="toctree-l5"><a class="reference internal" href="api_nmsis_core_dsp_intrinsic_simd_16b_multiply.html">SIMD 16-bit Multiply Instructions</a></li>
<li class="toctree-l5"><a class="reference internal" href="api_nmsis_core_dsp_intrinsic_simd_8b_multiply.html">SIMD 8-bit Multiply Instructions</a></li>
<li class="toctree-l5"><a class="reference internal" href="api_nmsis_core_dsp_intrinsic_simd_16b_misc.html">SIMD 16-bit Miscellaneous Instructions</a></li>
<li class="toctree-l5"><a class="reference internal" href="api_nmsis_core_dsp_intrinsic_simd_8b_misc.html">SIMD 8-bit Miscellaneous Instructions</a></li>
<li class="toctree-l5"><a class="reference internal" href="api_nmsis_core_dsp_intrinsic_simd_8b_unpack.html">SIMD 8-bit Unpacking Instructions</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../api_nmsis_core_dsp_intrinsic_non_simd.html">Non-SIMD Instructions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api_nmsis_core_dsp_intrinsic_part_simd_data_process.html">Partial-SIMD Data Processing Instructions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api_nmsis_core_dsp_intrinsic_64b_profile.html">64-bit Profile Instructions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api_nmsis_core_dsp_intrinsic_rv64_only.html">RV64 Only Instructions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../api_nmsis_core_dsp_intrinsic_nuclei_custom.html">Nuclei Customized N1/N2/N3 DSP Instructions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../core_periph_access.html">Peripheral Access</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_systick.html">Systick Timer(SysTimer)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_interrupt_exception.html">Interrupts and Exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_fpu.html">FPU Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_pmp.html">PMP Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_spmp.html">SPMP Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_cache.html">Cache Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_system_device.html">System Device Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../core_arm_compatiable.html">ARM Compatiable Functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dsp/index.html">NMSIS DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../nn/index.html">NMSIS NN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../appendix.html">Appendix</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">NMSIS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">NMSIS Core</a> &raquo;</li>
          <li><a href="../../index.html">NMSIS Core API</a> &raquo;</li>
          <li><a href="../../api_nmsis_core_dsp_intrinsic.html">Intrinsic Functions for SIMD Instructions</a> &raquo;</li>
          <li><a href="../api_nmsis_core_dsp_intrinsic_simd_data_process.html">SIMD Data Processing Instructions</a> &raquo;</li>
      <li>SIMD 16-bit Shift Instructions</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/core/api/nmsis_core_dsp_intrinsic/nmsis_core_dsp_intrinsic_simd_data_process/api_nmsis_core_dsp_intrinsic_simd_16b_shift.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="simd-16-bit-shift-instructions">
<span id="nmsis-core-api-simd-16-bit-shift-instructions"></span><h1>SIMD 16-bit Shift Instructions<a class="headerlink" href="#simd-16-bit-shift-instructions" title="Permalink to this headline"></a></h1>
<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gae0d8b0f00c558d5a7f1119b9d261779f"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_KSLL16</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">b)</span></span></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gaa85a466f43c98b2a2b34dc19e9c8e9d2"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_KSLRA16</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">int</span> <span class="pre">b)</span></span></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gae5b84af52b3d277117a4ee509df1504d"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_KSLRA16_U</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">int</span> <span class="pre">b)</span></span></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1ga567ef612a72bcfbdc3a12a55bafb3b8c"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_SLL16</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">b)</span></span></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gab98c44f440802e210dd48403997977fa"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_SRA16</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">b)</span></span></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1ga044ea66eee35c4d3ae3cb3d8e7aa3aa2"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_SRA16_U</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">b)</span></span></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gad077385854832151e700839fb03cfcfe"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_SRL16</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">b)</span></span></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1ga9b9494b2d305f51510e789484cbfd60b"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_SRL16_U</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">b)</span></span></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.__RV_KSLLI16">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1ga6926818b4df53eed570be8d922ca19ca"></span><span class="sig-name descname"><span class="n"><span class="pre">__RV_KSLLI16</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__RV_KSLLI16" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.__RV_SLLI16">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gae64e8d3cc171a464a716e317cd0eca66"></span><span class="sig-name descname"><span class="n"><span class="pre">__RV_SLLI16</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__RV_SLLI16" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.__RV_SRAI16">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1ga6fa2d780199be27817ab78209e4e234c"></span><span class="sig-name descname"><span class="n"><span class="pre">__RV_SRAI16</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__RV_SRAI16" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.__RV_SRAI16_U">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gaf1be1014728b97f6e3c5481ef7b9644e"></span><span class="sig-name descname"><span class="n"><span class="pre">__RV_SRAI16_U</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__RV_SRAI16_U" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.__RV_SRLI16">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gae990a9f2ef6b5f70f563327a56c693e0"></span><span class="sig-name descname"><span class="n"><span class="pre">__RV_SRLI16</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__RV_SRLI16" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.__RV_SRLI16_U">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1ga26055d836ed9bb21a1191bbf10197636"></span><span class="sig-name descname"><span class="n"><span class="pre">__RV_SRLI16_U</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.__RV_SRLI16_U" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">NMSIS_Core_DSP_Intrinsic_SIMD_16B_SHIFT</span></span></dt>
<dd><p>SIMD 16-bit Shift Instructions. </p>
<p>there are 14 SIMD 16-bit shift instructions. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="cpp macro">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1ga6926818b4df53eed570be8d922ca19ca"></span><span class="sig-name descname"><span class="n"><span class="pre">__RV_KSLLI16</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>KSLLI16 (SIMD 16-bit Saturating Shift Left Logical Immediate) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">KSLLI16</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">imm4u</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit elements logical left shift operations with saturation simultaneously. The shift amount is an immediate value.</p>
</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit data elements in Rs1 are left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the imm4u constant. Any shifted value greater than 2^15-1 is saturated to 2^15-1. Any shifted value smaller than -2^15 is saturated to -2^15. And the saturated results are written to Rd. If any saturation is performed, set OV bit to 1.</p>
</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sa</span> <span class="o">=</span> <span class="n">imm4u</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sa</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">res</span><span class="p">[(</span><span class="mi">15</span><span class="o">+</span><span class="n">sa</span><span class="p">):</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rs1</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">sa</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">15</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0x7fff</span><span class="p">;</span> <span class="n">OV</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="o">^</span><span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">;</span> <span class="n">OV</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Rd</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">15</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">Rd</span> <span class="o">=</span> <span class="n">Rs1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">RV32</span><span class="p">:</span> <span class="n">x</span><span class="o">=</span><span class="mf">1.</span><span class="o">..</span><span class="mi">0</span><span class="p">,</span>
<span class="k">for</span> <span class="n">RV64</span><span class="p">:</span> <span class="n">x</span><span class="o">=</span><span class="mf">3.</span><span class="o">..</span><span class="mi">0</span>
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> unsigned int type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gae64e8d3cc171a464a716e317cd0eca66"></span><span class="sig-name descname"><span class="n"><span class="pre">__RV_SLLI16</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>SLLI16 (SIMD 16-bit Shift Left Logical Immediate) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SLLI16</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">imm4</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit element logical left shift operations simultaneously. The shift amount is an immediate value.</p>
</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit elements in Rs1 are left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the imm4[3:0] constant. And the results are written to Rd.</p>
</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sa</span> <span class="o">=</span> <span class="n">imm4</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
<span class="n">Rd</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rs1</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">sa</span><span class="p">;</span>
<span class="k">for</span> <span class="n">RV32</span><span class="p">:</span> <span class="n">x</span><span class="o">=</span><span class="mf">1.</span><span class="o">..</span><span class="mi">0</span><span class="p">,</span>
<span class="k">for</span> <span class="n">RV64</span><span class="p">:</span> <span class="n">x</span><span class="o">=</span><span class="mf">3.</span><span class="o">..</span><span class="mi">0</span>
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> unsigned int type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1ga6fa2d780199be27817ab78209e4e234c"></span><span class="sig-name descname"><span class="n"><span class="pre">__RV_SRAI16</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>SRAI16 (SIMD 16-bit Shift Right Arithmetic Immediate) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SRAI16</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">imm4u</span>
<span class="n">SRAI16</span><span class="o">.</span><span class="n">u</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">imm4u</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit elements arithmetic right shift operations simultaneously. The shift amount is an immediate value. The</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form performs additional rounding up operations on the shifted results.</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit data elements in Rs1 are right-shifted arithmetically, that is, the shifted out bits are filled with the sign-bit of the 16-bit data elements. The shift amount is specified by the imm4u constant. For the rounding operation of the</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form, a value of 1 is added to the most significant discarded bit of each 16-bit data to calculate the final results. And the results are written to Rd.</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sa = imm4u[3:0];
if (sa &gt; 0) {
  if (`.u` form) { // SRAI16.u
    res[15:-1] = SE17(Rs1.H[x][15:sa-1]) + 1;
    Rd.H[x] = res[15:0];
  } else { // SRAI16
    Rd.H[x] = SE16(Rs1.H[x][15:sa]);
  }
} else {
  Rd = Rs1;
}
for RV32: x=1...0,
for RV64: x=3...0
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> unsigned long type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gaf1be1014728b97f6e3c5481ef7b9644e"></span><span class="sig-name descname"><span class="n"><span class="pre">__RV_SRAI16_U</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>SRAI16.u (SIMD 16-bit Rounding Shift Right Arithmetic Immediate) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SRAI16</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">imm4u</span>
<span class="n">SRAI16</span><span class="o">.</span><span class="n">u</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">imm4u</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit elements arithmetic right shift operations simultaneously. The shift amount is an immediate value. The</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form performs additional rounding up operations on the shifted results.</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit data elements in Rs1 are right-shifted arithmetically, that is, the shifted out bits are filled with the sign-bit of the 16-bit data elements. The shift amount is specified by the imm4u constant. For the rounding operation of the</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form, a value of 1 is added to the most significant discarded bit of each 16-bit data to calculate the final results. And the results are written to Rd.</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sa = imm4u[3:0];
if (sa &gt; 0) {
  if (`.u` form) { // SRAI16.u
    res[15:-1] = SE17(Rs1.H[x][15:sa-1]) + 1;
    Rd.H[x] = res[15:0];
  } else { // SRAI16
    Rd.H[x] = SE16(Rs1.H[x][15:sa]);
  }
} else {
  Rd = Rs1;
}
for RV32: x=1...0,
for RV64: x=3...0
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> unsigned long type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gae990a9f2ef6b5f70f563327a56c693e0"></span><span class="sig-name descname"><span class="n"><span class="pre">__RV_SRLI16</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>SRLI16 (SIMD 16-bit Shift Right Logical Immediate) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SRLI16</span> <span class="n">Rt</span><span class="p">,</span> <span class="n">Ra</span><span class="p">,</span> <span class="n">imm4u</span>
<span class="n">SRLI16</span><span class="o">.</span><span class="n">u</span> <span class="n">Rt</span><span class="p">,</span> <span class="n">Ra</span><span class="p">,</span> <span class="n">imm4u</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit elements logical right shift operations simultaneously. The shift amount is an immediate value. The</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form performs additional rounding up operations on the shifted results.</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit data elements in Rs1 are right-shifted logically, that is, the shifted out bits are filled with zero. The shift amount is specified by the imm4u constant. For the rounding operation of the</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form, a value of 1 is added to the most significant discarded bit of each 16-bit data element to calculate the final results. And the results are written to Rd.</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sa = imm4u;
if (sa &gt; 0) {
  if (`.u` form) { // SRLI16.u
    res[16:0] = ZE17(Rs1.H[x][15:sa-1]) + 1;
    Rd.H[x] = res[16:1];
  } else { // SRLI16
    Rd.H[x] = ZE16(Rs1.H[x][15:sa]);
  }
} else {
  Rd = Rs1;
}
for RV32: x=1...0,
for RV64: x=3...0
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> unsigned int type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1ga26055d836ed9bb21a1191bbf10197636"></span><span class="sig-name descname"><span class="n"><span class="pre">__RV_SRLI16_U</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>SRLI16.u (SIMD 16-bit Rounding Shift Right Logical Immediate) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SRLI16</span> <span class="n">Rt</span><span class="p">,</span> <span class="n">Ra</span><span class="p">,</span> <span class="n">imm4u</span>
<span class="n">SRLI16</span><span class="o">.</span><span class="n">u</span> <span class="n">Rt</span><span class="p">,</span> <span class="n">Ra</span><span class="p">,</span> <span class="n">imm4u</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit elements logical right shift operations simultaneously. The shift amount is an immediate value. The</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form performs additional rounding up operations on the shifted results.</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit data elements in Rs1 are right-shifted logically, that is, the shifted out bits are filled with zero. The shift amount is specified by the imm4u constant. For the rounding operation of the</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form, a value of 1 is added to the most significant discarded bit of each 16-bit data element to calculate the final results. And the results are written to Rd.</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sa = imm4u;
if (sa &gt; 0) {
  if (`.u` form) { // SRLI16.u
    res[16:0] = ZE17(Rs1.H[x][15:sa-1]) + 1;
    Rd.H[x] = res[16:1];
  } else { // SRLI16
    Rd.H[x] = ZE16(Rs1.H[x][15:sa]);
  }
} else {
  Rd = Rs1;
}
for RV32: x=1...0,
for RV64: x=3...0
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> unsigned int type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gae0d8b0f00c558d5a7f1119b9d261779f"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_KSLL16</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">b)</span></span></dt>
<dd><p>KSLL16 (SIMD 16-bit Saturating Shift Left Logical) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">KSLL16</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">Rs2</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit elements logical left shift operations with saturation simultaneously. The shift amount is a variable from a GPR.</p>
</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit data elements in Rs1 are left-shifted logically. The shifted out bits are filled with zero and the shift amount is specified by the low-order 4-bits of the value in the Rs2 register. Any shifted value greater than 2^15-1 is saturated to 2^15-1. Any shifted value smaller than -2^15 is saturated to -2^15. And the saturated results are written to Rd. If any saturation is performed, set OV bit to 1.</p>
</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sa</span> <span class="o">=</span> <span class="n">Rs2</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sa</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">res</span><span class="p">[(</span><span class="mi">15</span><span class="o">+</span><span class="n">sa</span><span class="p">):</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rs1</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">sa</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">15</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0x7fff</span><span class="p">;</span> <span class="n">OV</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="o">^</span><span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">;</span> <span class="n">OV</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Rd</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">15</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">Rd</span> <span class="o">=</span> <span class="n">Rs1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">RV32</span><span class="p">:</span> <span class="n">x</span><span class="o">=</span><span class="mf">1.</span><span class="o">..</span><span class="mi">0</span><span class="p">,</span>
<span class="k">for</span> <span class="n">RV64</span><span class="p">:</span> <span class="n">x</span><span class="o">=</span><span class="mf">3.</span><span class="o">..</span><span class="mi">0</span>
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> unsigned int type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gaa85a466f43c98b2a2b34dc19e9c8e9d2"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_KSLRA16</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">int</span> <span class="pre">b)</span></span></dt>
<dd><p>KSLRA16 (SIMD 16-bit Shift Left Logical with Saturation or Shift Right Arithmetic) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">KSLRA16</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">Rs2</span>
<span class="n">KSLRA16</span><span class="o">.</span><span class="n">u</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">Rs2</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit elements logical left (positive) or arithmetic right (negative) shift operation with Q15 saturation for the left shift. The</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form performs additional rounding up operations for the right shift.</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit data elements of Rs1 are left-shifted logically or right-shifted arithmetically based on the value of Rs2[4:0]. Rs2[4:0] is in the signed range of [-2^4, 2^4-1]. A positive Rs2[4:0] means logical left shift and a negative Rs2[4:0] means arithmetic right shift. The shift amount is the absolute value of Rs2[4:0]. However, the behavior of</p>
<code class="docutils literal notranslate"><span class="pre">Rs2[4:0]==-2^4</span> <span class="pre">(0x10)</span></code> is defined to be equivalent to the behavior of <code class="docutils literal notranslate"><span class="pre">Rs2[4:0]==-(2^4-1)</span> <span class="pre">(0x11)</span></code>. The left-shifted results are saturated to the 16-bit signed integer range of [-2^15, 2^15-1]. For the <code class="docutils literal notranslate"><span class="pre">.u</span></code> form of the instruction, the right-shifted results are added a 1 to the most significant discarded bit position for rounding effect. After the shift, saturation, or rounding, the final results are written to Rd. If any saturation happens, this instruction sets the OV flag. The value of Rs2[31:5] will not affect this instruction.</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>if (Rs2[4:0] &lt; 0) {
  sa = -Rs2[4:0];
  sa = (sa == 16)? 15 : sa;
  if (`.u` form) {
    res[15:-1] = SE17(Rs1.H[x][15:sa-1]) + 1;
    Rd.H[x] = res[15:0];
  } else {
    Rd.H[x] = SE16(Rs1.H[x][15:sa]);
  }
} else {
  sa = Rs2[3:0];
  res[(15+sa):0] = Rs1.H[x] &lt;&lt;(logic) sa;
  if (res &gt; (2^15)-1) {
    res[15:0] = 0x7fff; OV = 1;
  } else if (res &lt; -2^15) {
    res[15:0] = 0x8000; OV = 1;
  }
  d.H[x] = res[15:0];
}
for RV32: x=1...0,
for RV64: x=3...0
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> int type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gae5b84af52b3d277117a4ee509df1504d"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_KSLRA16_U</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">int</span> <span class="pre">b)</span></span></dt>
<dd><p>KSLRA16.u (SIMD 16-bit Shift Left Logical with Saturation or Rounding Shift Right Arithmetic) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">KSLRA16</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">Rs2</span>
<span class="n">KSLRA16</span><span class="o">.</span><span class="n">u</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">Rs2</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit elements logical left (positive) or arithmetic right (negative) shift operation with Q15 saturation for the left shift. The</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form performs additional rounding up operations for the right shift.</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit data elements of Rs1 are left-shifted logically or right-shifted arithmetically based on the value of Rs2[4:0]. Rs2[4:0] is in the signed range of [-2^4, 2^4-1]. A positive Rs2[4:0] means logical left shift and a negative Rs2[4:0] means arithmetic right shift. The shift amount is the absolute value of Rs2[4:0]. However, the behavior of</p>
<code class="docutils literal notranslate"><span class="pre">Rs2[4:0]==-2^4</span> <span class="pre">(0x10)</span></code> is defined to be equivalent to the behavior of <code class="docutils literal notranslate"><span class="pre">Rs2[4:0]==-(2^4-1)</span> <span class="pre">(0x11)</span></code>. The left-shifted results are saturated to the 16-bit signed integer range of [-2^15, 2^15-1]. For the <code class="docutils literal notranslate"><span class="pre">.u</span></code> form of the instruction, the right-shifted results are added a 1 to the most significant discarded bit position for rounding effect. After the shift, saturation, or rounding, the final results are written to Rd. If any saturation happens, this instruction sets the OV flag. The value of Rs2[31:5] will not affect this instruction.</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>if (Rs2[4:0] &lt; 0) {
  sa = -Rs2[4:0];
  sa = (sa == 16)? 15 : sa;
  if (`.u` form) {
    res[15:-1] = SE17(Rs1.H[x][15:sa-1]) + 1;
    Rd.H[x] = res[15:0];
  } else {
    Rd.H[x] = SE16(Rs1.H[x][15:sa]);
  }
} else {
  sa = Rs2[3:0];
  res[(15+sa):0] = Rs1.H[x] &lt;&lt;(logic) sa;
  if (res &gt; (2^15)-1) {
    res[15:0] = 0x7fff; OV = 1;
  } else if (res &lt; -2^15) {
    res[15:0] = 0x8000; OV = 1;
  }
  d.H[x] = res[15:0];
}
for RV32: x=1...0,
for RV64: x=3...0
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> int type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1ga567ef612a72bcfbdc3a12a55bafb3b8c"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_SLL16</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">b)</span></span></dt>
<dd><p>SLL16 (SIMD 16-bit Shift Left Logical) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SLL16</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">Rs2</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit elements logical left shift operations simultaneously. The shift amount is a variable from a GPR.</p>
</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit elements in Rs1 are left-shifted logically. And the results are written to Rd. The shifted out bits are filled with zero and the shift amount is specified by the low-order 4-bits of the value in the Rs2 register.</p>
</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sa</span> <span class="o">=</span> <span class="n">Rs2</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
<span class="n">Rd</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rs1</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">sa</span><span class="p">;</span>
<span class="k">for</span> <span class="n">RV32</span><span class="p">:</span> <span class="n">x</span><span class="o">=</span><span class="mf">1.</span><span class="o">..</span><span class="mi">0</span><span class="p">,</span>
<span class="k">for</span> <span class="n">RV64</span><span class="p">:</span> <span class="n">x</span><span class="o">=</span><span class="mf">3.</span><span class="o">..</span><span class="mi">0</span>
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> unsigned int type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gab98c44f440802e210dd48403997977fa"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_SRA16</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">b)</span></span></dt>
<dd><p>SRA16 (SIMD 16-bit Shift Right Arithmetic) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SRA16</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">Rs2</span>
<span class="n">SRA16</span><span class="o">.</span><span class="n">u</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">Rs2</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit element arithmetic right shift operations simultaneously. The shift amount is a variable from a GPR. The</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form performs additional rounding up operations on the shifted results.</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit data elements in Rs1 are right-shifted arithmetically, that is, the shifted out bits are filled with the sign-bit of the data elements. The shift amount is specified by the low-order 4-bits of the value in the Rs2 register. For the rounding operation of the</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form, a value of 1 is added to the most significant discarded bit of each 16-bit data element to calculate the final results. And the results are written to Rd.</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sa = Rs2[3:0];
if (sa != 0) {
  if (`.u` form) { // SRA16.u
    res[15:-1] = SE17(Rs1.H[x][15:sa-1]) + 1;
    Rd.H[x] = res[15:0];
  } else { // SRA16
    Rd.H[x] = SE16(Rs1.H[x][15:sa])
  }
} else {
  Rd = Rs1;
}
for RV32: x=1...0,
for RV64: x=3...0
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> unsigned long type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1ga044ea66eee35c4d3ae3cb3d8e7aa3aa2"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_SRA16_U</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">b)</span></span></dt>
<dd><p>SRA16.u (SIMD 16-bit Rounding Shift Right Arithmetic) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SRA16</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">Rs2</span>
<span class="n">SRA16</span><span class="o">.</span><span class="n">u</span> <span class="n">Rd</span><span class="p">,</span> <span class="n">Rs1</span><span class="p">,</span> <span class="n">Rs2</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit element arithmetic right shift operations simultaneously. The shift amount is a variable from a GPR. The</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form performs additional rounding up operations on the shifted results.</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit data elements in Rs1 are right-shifted arithmetically, that is, the shifted out bits are filled with the sign-bit of the data elements. The shift amount is specified by the low-order 4-bits of the value in the Rs2 register. For the rounding operation of the</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form, a value of 1 is added to the most significant discarded bit of each 16-bit data element to calculate the final results. And the results are written to Rd.</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sa = Rs2[3:0];
if (sa != 0) {
  if (`.u` form) { // SRA16.u
    res[15:-1] = SE17(Rs1.H[x][15:sa-1]) + 1;
    Rd.H[x] = res[15:0];
  } else { // SRA16
    Rd.H[x] = SE16(Rs1.H[x][15:sa])
  }
} else {
  Rd = Rs1;
}
for RV32: x=1...0,
for RV64: x=3...0
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> unsigned long type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1gad077385854832151e700839fb03cfcfe"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_SRL16</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">b)</span></span></dt>
<dd><p>SRL16 (SIMD 16-bit Shift Right Logical) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SRL16</span> <span class="n">Rt</span><span class="p">,</span> <span class="n">Ra</span><span class="p">,</span> <span class="n">Rb</span>
 <span class="n">SRL16</span><span class="o">.</span><span class="n">u</span> <span class="n">Rt</span><span class="p">,</span> <span class="n">Ra</span><span class="p">,</span> <span class="n">Rb</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit elements logical right shift operations simultaneously. The shift amount is a variable from a GPR. The</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form performs additional rounding upoperations on the shifted results.</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit data elements in Rs1 are right-shifted logically, that is, the shifted out bits are filled with zero. The shift amount is specified by the low-order 4-bits of the value in the Rs2 register. For the rounding operation of the</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form, a value of 1 is added to the most significant discarded bit of each 16-bit data element to calculate the final results. And the results are written to Rd.</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sa = Rs2[3:0];
if (sa &gt; 0) {
  if (`.u` form) { // SRL16.u
    res[16:0] = ZE17(Rs1.H[x][15:sa-1]) + 1;
    Rd.H[x] = res[16:1];
  } else { // SRL16
    Rd.H[x] = ZE16(Rs1.H[x][15:sa]);
  }
} else {
  Rd = Rs1;
}
for RV32: x=1...0,
for RV64: x=3...0
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> unsigned int type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp">
<span class="target" id="group__NMSIS__Core__DSP__Intrinsic__SIMD__16B__SHIFT_1ga9b9494b2d305f51510e789484cbfd60b"></span><span class="sig-name descname"><span class="pre">__STATIC_FORCEINLINE</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">__RV_SRL16_U</span> <span class="pre">(unsigned</span> <span class="pre">long</span> <span class="pre">a,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">b)</span></span></dt>
<dd><p>SRL16.u (SIMD 16-bit Rounding Shift Right Logical) </p>
<p><strong>Type</strong>: SIMD</p>
<p><strong>Syntax</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SRL16</span> <span class="n">Rt</span><span class="p">,</span> <span class="n">Ra</span><span class="p">,</span> <span class="n">Rb</span>
 <span class="n">SRL16</span><span class="o">.</span><span class="n">u</span> <span class="n">Rt</span><span class="p">,</span> <span class="n">Ra</span><span class="p">,</span> <span class="n">Rb</span>
</pre></div>
</div>
</p>
<p><strong>Purpose</strong><p>:</p>
<p>Do 16-bit elements logical right shift operations simultaneously. The shift amount is a variable from a GPR. The</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form performs additional rounding upoperations on the shifted results.</p>
<p><strong>Description</strong><p>:</p>
<p>The 16-bit data elements in Rs1 are right-shifted logically, that is, the shifted out bits are filled with zero. The shift amount is specified by the low-order 4-bits of the value in the Rs2 register. For the rounding operation of the</p>
<code class="docutils literal notranslate"><span class="pre">.u</span></code> form, a value of 1 is added to the most significant discarded bit of each 16-bit data element to calculate the final results. And the results are written to Rd.</p>
<p><strong>Operations</strong>:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sa = Rs2[3:0];
if (sa &gt; 0) {
  if (`.u` form) { // SRL16.u
    res[16:0] = ZE17(Rs1.H[x][15:sa-1]) + 1;
    Rd.H[x] = res[16:1];
  } else { // SRL16
    Rd.H[x] = ZE16(Rs1.H[x][15:sa]);
  }
} else {
  Rd = Rs1;
}
for RV32: x=1...0,
for RV64: x=3...0
</pre></div>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – <strong>[in]</strong> unsigned long type of value stored in a </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> unsigned int type of value stored in b </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>value stored in unsigned long type </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="api_nmsis_core_dsp_intrinsic_simd_8b_addsub.html" class="btn btn-neutral float-left" title="SIMD 8-bit Addition &amp; Subtraction Instructions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="api_nmsis_core_dsp_intrinsic_simd_8b_shift.html" class="btn btn-neutral float-right" title="SIMD 8-bit Shift Instructions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-Present, Nuclei.
      <span class="lastupdated">Last updated on May 23, 2023.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>